#!/usr/bin/env python3

import os
import json
import random
import requests
import apt
import apt_pkg
import time
import sys
import psutil
import subprocess
import syslog
import dbus

import threading
import psutil
import signal 
import systemd.daemon 

import pyinotify
from pyinotify import WatchManager, Notifier, ThreadedNotifier, EventsCodes, ProcessEvent


class LliurexAutoUpgrade:
	
	DEBUG=True
	SYSLOG=True
	ENFORCE_LLIUREX_NET=True
	IGNORE_UPDATE_ERROR=True
	ENABLE_TAG_NOTIFY=False
	RANDOM_SLEEP_WINDOW=30
	SLEEP_TIME=60*40
	DPKG_SLEEP=1
	ALTERNATE_SLEEP_TIME=60
	MAX_RETRIES_FIRST_UPDATE=10
	MAX_ERROR_COUNTER=3
	
	SLEEP_TIME_RESOLUTION=1
	
	def __init__(self):
		
		self.actions_url="http://svnlliurexnet.gva.es/leia/public/lliurex_actions.json"
		self.hostname="svnlliurexnet.gva.es"
		self.org_id="VATES-S4611001A"
		self.tags_dir="/etc/lliurex-auto-upgrade/tags/"
		self.disable_file="/etc/lliurex-auto-upgrade/disabled"
		self.run_dir="/run/lliurex-auto-upgrade"
		self.pid_file=self.run_dir+"/lliurex-auto-upgrade.pid"
		
		self.source_list="/usr/share/lliurex-auto-upgrade/sources/lliurex.list"
		
		self.packages_to_update=False
		self.packages_to_enforce=False
		
		self.last_update=None
		self.new_tag_signal=False
		self.error_counter=0

		apt_pkg.init_config()
		apt_pkg.config.set("Dir::Etc::SourceList",self.source_list)
		
		
	#def init
	
	def serve_forever(self):
		
		self.random_sleep_seed=int(random.random()*LliurexAutoUpgrade.RANDOM_SLEEP_WINDOW)
		self.updating_loop=False
		
		bus=dbus.SystemBus()
		obj=bus.get_object("org.freedesktop.login1","/org/freedesktop/login1")
		manager = dbus.Interface(obj, "org.freedesktop.login1.Manager")

		if not os.path.exists(self.run_dir):
			os.makedirs(self.run_dir)
		self.write_pid()		

		if LliurexAutoUpgrade.ENABLE_TAG_NOTIFY:
			self.start_inotify()
			
		signal.signal(signal.SIGUSR1,self.force_loop_signal)
			
		if self.is_auto_update_configured():
		
			self.flavor=self.get_lliurex_flavor()
			self.tags=self.get_tags()
		
			first_round_success=False
			first_try_error_count=0
		
			self.pprint("Starting...")
			self.print_system_info()
			current_sleep_counter=0
			sleep_counter=1
			
			while True:
				# Needed for systemd to know service is up and running
				systemd.daemon.notify("READY=1")
				
				if self.last_update==None and not self.new_tag_signal:
					systemd.daemon.notify("STATUS=First run sleep")
					# we only sleep a random amount the first time
					time.sleep(self.random_sleep_seed)
					
				current_sleep_counter+=1
				
				# Every SLEEP_TIME_RESOLUTION this IF is checked. We have either slept the current sleep_counter amount
				# or a new tag has been written or else we sleep another SLEEP_TIME_RESOLUTION until sleept_counter is reached
				if current_sleep_counter >= sleep_counter or self.new_tag_signal:
						
					current_sleep_counter=0
					self.updating_loop=True
					
					try:
						
						# wait for dpkgs to end
						while self.find_process("dpkg"):
							systemd.daemon.notify("STATUS=Waiting for dpkg to finish.")
							time.sleep(LliurexAutoUpgrade.DPKG_SLEEP)
								
						systemd.daemon.notify("STATUS=Checking remote file")
						self.remote_actions=self.get_actions_file()
						if self.remote_actions!=None:
							
							# its either a new file or we previously failed to complete the loop 
							if self.last_update!=self.remote_actions["last_update"] or self.error_counter > 0 or self.new_tag_signal:
								
								self.pprint("Updating phase...")
								self.pprint("")
								self.last_update=self.remote_actions["last_update"]
								self.apt_cache=apt.Cache()
								self.pprint("\tUpdating cache...")
								try:
									self.apt_cache.update()
									# needs to be reopened after being updated
									self.apt_cache.open()
								except Exception as update_exc:
									if LliurexAutoUpgrade.IGNORE_UPDATE_ERROR:
										pass
									else:
										raise update_exc
								
								# This should be a safe place to reset new_tag_signal
								self.new_tag_signal=False

								# this should not be necessary
								#self.pprint("\tValidating %h certificate..."%self.hostname)
								#self.check_certificate(self.hostname,self.org_id)
								
								self.pprint("\tGathering actions from server...")
								self.my_actions=self.gather_actions()
								self.print_my_actions()
								self.mark_update()
								self.mark_enforce()
								self.pprint("\tInhibiting shutdown...")
								fd_shutdown = manager.Inhibit("shutdown","lliurex-auto-upgrade","Updating system","block")
								real_fd=fd_shutdown.take()
								try:
									self.execute()
								finally:
									self.pprint("\tReleasing shutdown inhibition...")
									os.close(real_fd)
								self.pprint("Done")
								self.pprint("")
							else:
								self.pprint("Nothing to do")
								self.pprint("")
								systemd.daemon.notify("STATUS=Nothing to execute. Waiting for new updates.")
						
						# everything went wright. Lets clean status variables
						self.error_counter=0
						self.updating_loop=False
						
						if self.remote_actions != None:
							first_round_success=True
							
					except Exception as e:
						self.pprint("Exception: %s"%str(e))
						systemd.daemon.notify("STATUS=Failed to execute: %s"%str(e))
						self.error_counter+=1
						self.updating_loop=False

					
					if first_round_success:
						# either everything is ok
						sleep_counter=LliurexAutoUpgrade.SLEEP_TIME
						# if we fail for some unknown reason. Lets try a faster loop MAX_ERROR_COUNTER times
						if self.error_counter > 0 and self.error_counter < LliurexAutoUpgrade.MAX_ERROR_COUNTER:
							sleep_counter=LliurexAutoUpgrade.ALTERNATE_SLEEP_TIME
							
						self.pprint("Sleeping %s minutes until next loop..."%(sleep_counter/60))
						
					else:
						first_try_error_count+=1
						if first_try_error_count == LliurexAutoUpgrade.MAX_RETRIES_FIRST_UPDATE:
							# next loop will wake in LliurexAutoUpgrade.SLEEP_TIME hour
							first_round_success=True
						else:
							# we have to reset last_update value to force new try after sleeping
							self.last_update=None
						self.pprint("Sleeping a reduced time since we failed to complete first run on try %s/%s ..."%(first_try_error_count,LliurexAutoUpgrade.MAX_RETRIES_FIRST_UPDATE))
						sleep_counter=LliurexAutoUpgrade.ALTERNATE_SLEEP_TIME
						sleep_counter=LliurexAutoUpgrade.ALTERNATE_SLEEP_TIME
				else:
					# current_sleep_counter is still bellow sleep_counter. We do nothing
					pass
					#self.pprint("Sleeping... %s/%s"%(current_sleep_counter,sleep_counter))
				
				time.sleep(LliurexAutoUpgrade.SLEEP_TIME_RESOLUTION)
				
		else:
			self.pprint("'%s' exists, service is disabled. Exiting..."%self.disable_file)
		
	#def server_loop
	
	def force_loop_signal(self,signum,frame):
		
		self.pprint("Force loop signal received.")
		
		while self.updating_loop:
			time.sleep(1)
		
		self.tags=self.get_tags()
		self.print_system_info()
		self.new_tag_signal=True
		self.last_update=None		
		
	#def force_loop_signal
	
	def send_force_signal(self):
		
		bus=dbus.SystemBus()
		sdobj=bus.get_object("org.freedesktop.systemd1","/org/freedesktop/systemd1")
		systemd_manager=dbus.Interface(sdobj,"org.freedesktop.systemd1.Manager")
		
		unit_path=systemd_manager.GetUnit("lliurex-auto-upgrade.service")
		unit_obj=bus.get_object("org.freedesktop.systemd1",unit_path)
		unit_iface=dbus.Interface(unit_obj,"org.freedesktop.systemd1.Unit")
		
		unit_iface.Kill("main",signal.SIGUSR1.value)
		
	#def send_force_signal
	
	def pprint(self,data):
		
		if LliurexAutoUpgrade.DEBUG:
			print("[LAU] %s"%str(data))
			
		if LliurexAutoUpgrade.SYSLOG:
			syslog.syslog("[LAU] %s"%str(data).replace("\t","    "))
		
	#def pprint

	def find_process(self,name,strict=True):
		
		for proc in psutil.process_iter():
			if strict:
				if name.lower()== proc.name().lower():
					return True
			else:
				if name.lower() in proc.name().lower():
					return True
		return False
		
	#def find_process
	
	def write_pid(self):
		
		if os.path.exists(self.pid_file):
			f=open(self.pid_file)
			self.pid=int(f.read())
			f.close()
		
			if psutil.pid_exists(self.pid):
				self.pprint("Another lliurex-auto-upgrade process (%s) seems to be running. Exiting..."%self.pid)
				sys.exit(0)

		f=open(self.pid_file,"w")
		f.write(str(os.getpid()))
		f.close()
		
	#def write_pid	

	def start_inotify(self):

		t=threading.Thread(target=self.__inotify,name="lliurex-auto-upgrade.start_inotify thread")
		t.daemon=True
		t.start()

	#def start_inotify
	
	def __inotify(self):
		
		
		wm=WatchManager()
		mask=pyinotify.IN_CLOSE_WRITE
			
		class Process_handler(ProcessEvent):
				
			def __init__(self,main):
				
				self.main=main
				
			def process_IN_CLOSE_WRITE(self,event):

				self.main.pprint("New tag %s detected. Queuing new loop"%event.name)
				systemd.daemon.notify("STATUS=New tag %s detected. Queuing new loop"%event.name)
				self.main.tags=self.main.get_tags()
				self.main.print_system_info()
				self.main.new_tag_signal=True
				self.main.last_update=None
	
		notifier=Notifier(wm,Process_handler(self))
		wm.add_watch(self.tags_dir,mask,rec=True)
			
		while True:
			try:
					
				notifier.process_events()
				if notifier.check_events():
					notifier.read_events()
				
			except Exception as e:
				self.pprint(e)
				notifier.stop()
					
		return False
	
	#def _inotify	
	
	def is_auto_update_configured(self):
		
		if os.path.exists(self.disable_file):
			return False
		
		return True
		
	#def is_auto_update_configured
	
	def is_package_from_lliurex_net(self,package):
		
		if not LliurexAutoUpgrade.ENFORCE_LLIUREX_NET:
			# if we dont enforce lliurex.net this check always returns true
			return True
		
		if package in self.apt_cache:
			if self.apt_cache[package].candidate.uri !=None and self.apt_cache[package].candidate.uri.startswith("http://lliurex.net/"):
				return True
				
		return False
		
	#def is_package_from_lliurexnet
	
	def is_package_installed(self,package):
		
		if package in self.apt_cache:
			return self.apt_cache[package].is_installed
			
		return False
		
	#def is_package_installed
	
	def is_package_upgradable(self,package):
		
		if package in self.apt_cache:
			if self.is_package_from_lliurex_net(package):
				return self.apt_cache[package].is_upgradable
			
		return False
		
	#def is_package_upgradable
	
	def check_certificate(self,hostname,org_id):
		
		cert=None
		verified=False
		context=ssl.create_default_context()
		try:
			with context.wrap_socket(socket.socket(), server_hostname=hostname) as s:
				s.connect((hostname,443))
				cert = s.getpeercert()
				
			if not cert:
				self.pprint("Failed to get certificate")
				
			if "subject" not in cert:
				self.pprint("Invalid certificate data")
			for item in cert["subject"]:
				key,value = item[0]
				if key=="organizationIdentifier":
					verified = value==org_id
			
		except Exception as e:
			self.pprint("Failed to verify certificate.")
			
		if not verfied:
			raise Exception("Failed to verify certificate.")
		
		return verified
		
	#def check_certificate
	
	def get_actions_file(self,url=None):
		
		data=None
		if url==None:
			url=self.actions_url
		
		if not os.path.exists("lliurex_actions.json"):
			try:
				response = requests.get(url)
				data = response.json()
			except Exception as e:
				self.pprint("Failed to download remote file.")
				data=None
		else:
			f=open("lliurex_actions.json")
			data=json.load(f)
			f.close()

		return data
		
	#def get_actions_file
	
	def get_lliurex_flavor(self):
		
		return subprocess.check_output("lliurex-version -f",shell=True).decode("utf-8").strip("\n")
		
	#def get_lliurex_flavor
	
	def get_tags(self):
		
		tags=[]
		if os.path.exists(self.tags_dir):
			dir_list=os.listdir(self.tags_dir)
			for item in dir_list:
				if os.path.isfile(self.tags_dir+item):
					tags.append(item)
		
		return tags
		
	#def get_tags
	
	def gather_actions(self):
		
		actions={}
		actions["update"]=[]
		actions["enforce"]=[]
		flavors=["common"]
		
		if self.flavor!=None:
			flavors.append(self.flavor)
		
		for flavor in flavors:
			
			if flavor in self.remote_actions["flavors"]:
				for action in self.remote_actions["flavors"][flavor]["update"]:
					if action not in actions["update"]:
						actions["update"].append(action)

				for action in self.remote_actions["flavors"][flavor]["enforce"]:
					if action not in actions["enforce"]:
						actions["enforce"].append(action)
					
		for tag in self.tags:
			
			if tag in self.remote_actions["tags"]:
				for action in self.remote_actions["tags"][tag]["update"]:
					if action not in actions["update"]:
						actions["update"].append(action)
			
				for action in self.remote_actions["tags"][tag]["enforce"]:
					if action not in actions["enforce"]:
						actions["enforce"].append(action)
		
		filtered_update=[]
		for update in actions["update"]:
			if self.is_package_installed(update):
				filtered_update.append(update)

		actions["update"]=filtered_update
		return actions
		
	#def gather_actions
	
	def mark_update(self):
		
		self.packages_to_update=False
		
		for package in self.my_actions["update"]:
			if self.is_package_upgradable(package):
				self.pprint("Marking %s update..."%package)
				self.apt_cache[package].mark_upgrade()
				print(dir(self.apt_cache[package]))
				self.packages_to_update=True
				
	#def mark_update
	
	def mark_enforce(self):
		
		self.packages_to_enforce=False
		
		for package in self.my_actions["enforce"]:
			if package in self.apt_cache and not self.is_package_installed(package) and self.is_package_from_lliurex_net(package):
				self.pprint("Marking %s enforce..."%package)
				self.packages_to_enforce=True
				self.apt_cache[package].mark_install()
			else:
				if self.is_package_upgradable(package):
					self.pprint("Marking %s enforce..."%package)
					self.packages_to_enforce=True
					self.apt_cache[package].mark_upgrade()
					
	#def mark_enforce
	
	def fixes_before_execution(self):
		
		if self.apt_cache.dpkg_journal_dirty:
			self.pprint("\t\tExecuting dpkg --configure -a ...")
			os.system("dpkg --configure -a")
		self.pprint("\t\tExecuting apt install -f...")
		os.system("apt install -f")
		# this call is caousing marked packages not to update. Trying to call apt install -f manually instead
		# self.apt_cache.fix_broken()
		
	#def fixes_before_execution
	
	def execute(self):
		
		if self.packages_to_update or self.packages_to_enforce:
			systemd.daemon.notify("STATUS=Checking apt/dpkg status before installing packages")
			self.pprint("\tUpdating system...")
			self.fixes_before_execution()
			
			package_list=""
			
			for package in self.apt_cache:
				if self.apt_cache[package].marked_install or self.apt_cache[package].marked_upgrade:
					package_list+="%s "%package
			
			systemd.daemon.notify("STATUS=Installing packages: %s"%package_list)
			self.pprint("\t\tInstalling packages: %s"%package_list)
			self.apt_cache.commit()
			systemd.daemon.notify("STATUS=Installing finished. Waiting for new updates.")
		else:
			systemd.daemon.notify("STATUS=Nothing to execute. Waiting for new updates.")
			self.pprint("")
			self.pprint("\tNothing to execute. Everything is up to date")
			self.pprint("")
		
	#def execute
	
	def print_my_actions(self):
		
		self.pprint("\tUpdate:")
		self.pprint("\t\t%s"%self.my_actions["update"])
		self.pprint("\tEnforce:")
		self.pprint("\t\t%s"%self.my_actions["enforce"])
		
	#def print_my_actions
	
	def print_system_info(self):
		
		self.pprint("")
		self.pprint("System info:")
		self.pprint("\tFlavor: %s"%str(self.flavor))
		self.pprint("\tTags: %s"%str(self.tags))
		self.pprint("")
		
	#def print_system_info
	
	def print_remote_actions(self,data):
		
		'''
		self.pprint("")
		self.pprint("Last Update: %s"%data["last_update"])
		self.pprint("Flavors:")
		for flavor in data["flavors"]:
			self.pprint("\t%s"%flavor)
			self.pprint("\t\tUpdate:")
			for update in data["flavors"][flavor]["update"]:
				self.pprint("\t\t\t%s"%update)
			self.pprint("\t\tEnforce:")
			for enforce in data["flavors"][flavor]["enforce"]:
				self.pprint("\t\t\t%s"%enforce)	
		'''
		print(json.dumps(data,indent=4))
		
	#def print_remote_actions
		
	def dry_run(self,print_actions=False):
		
		try:

			self.flavor=self.get_lliurex_flavor()
			self.tags=self.get_tags()

			self.remote_actions=self.get_actions_file()
			
			self.apt_cache=apt.Cache()
			self.apt_cache.update()
			self.apt_cache.open()
			
			self.my_actions=self.gather_actions()
			if print_actions:
				self.print_my_actions()
				self.pprint("")
				
			self.mark_update()
			self.mark_enforce()

			# Forcing package to see something when testing
			# This line should be commented 
			self.apt_cache["systemd"].mark_upgrade()
			
			changes=self.apt_cache.get_changes()
			
			for package in changes:
				
				self.pprint("%s=%s needs to be installed."%(package.name,package.candidate.version))
				
			if len(changes)==0:
				
				self.pprint("Up to date. Nothing to install")
				
		except Exception as e:
			self.pprint("[!] Failed to dry-run: %s"%str(e))
			
	#def dry_run
	
	def _remote_tags(self):
		
		data=lau.get_actions_file()
		lau.print_remote_actions(data)
		
	#def remote_tags
	
	def _system_tags(self):
		
		self.flavor=lau.get_lliurex_flavor()
		self.tags=lau.get_tags()
		self.print_system_info()
		
	#def system_tags
	
	def usage(self):
		
		print("USAGE: lliurex-auto-upgrade [ serve | reload | remote-tags | system-tags | dry-run ]")
		print("")
		print("\tserve: server used by systemd to manage updates automatically.")
		print("\treload: forces server to reload local and remote tags as soon as possible.")
		print("\tremote-tags: print remote rules.")
		print("\tsystem-tags: print system tags.")
		print("\tdry-run: Checks local and remote tags and lists pending updates.")
		print()
		
		
	#def usage
	
#class LliurexAutoUpdater


if __name__=="__main__":
	
	lau=LliurexAutoUpgrade()
	if len(sys.argv)>1:
		
		option=sys.argv[1]
		if option=="serve":
			lau.serve_forever()
		if option=="reload":
			lau.send_force_signal()
		if option=="remote-tags":
			lau._remote_tags()
		if option=="system-tags":
			lau._system_tags()
		if option=="dry-run":
			lau.dry_run(print_actions=True)
			
	else:
		lau.usage()

			