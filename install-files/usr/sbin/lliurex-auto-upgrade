#!/usr/bin/env python3

import os
import json
import random
import requests
import apt
import time
import sys
import psutil
import subprocess
import syslog
import dbus

import systemd.daemon 

import pyinotify
from pyinotify import WatchManager, Notifier, ThreadedNotifier, EventsCodes, ProcessEvent

class LliurexAutoUpgrade:
	
	DEBUG=True
	SYSLOG=True
	ENFORCE_LLIUREX_NET=True
	IGNORE_UPDATE_ERROR=True
	RANDOM_SLEEP_WINDOW=30
	SLEEP_TIME=60*40
	ALTERNATE_SLEEP_TIME=60
	MAX_RETRIES_FIRST_UPDATE=10
		
	def __init__(self):
		
		self.actions_url="http://svnlliurexnet.gva.es/leia/public/lliurex_actions.json"
		self.hostname="svnlliurexnet.gva.es"
		self.org_id="VATES-S4611001A"
		self.tags_dir="/etc/lliurex-auto-upgrade/tags/"
		self.disable_file="/etc/lliurex-auto-upgrade/disabled"
		self.pid_file="/run/lliurex-auto-upgrade.pid"
		self.packages_to_update=False
		self.packages_to_enforce=False
		self.random_sleep_seed=int(random.random()*LliurexAutoUpgrade.RANDOM_SLEEP_WINDOW)
		self.last_update=None
		self.new_tag_signal=False
		
		bus=dbus.SystemBus()
		obj=bus.get_object("org.freedesktop.login1","/org/freedesktop/login1")
		manager = dbus.Interface(obj, "org.freedesktop.login1.Manager")
		
		self.write_pid()
		self.start_inotify()
		
		if self.is_auto_update_configured():
		
			self.flavor=self.get_lliurex_flavor()
			self.tags=self.get_tags()
		
			first_round_success=False
			error_count=0
		
			self.pprint("Starting...")
			self.print_system_info()
			current_sleep_counter=0
			sleep_counter=1
			
			while True:
				# Needed for systemd to know service is up and running
				systemd.daemon.notify("READY=1")
				
				if self.last_update==None and not self.new_tag_signal:
					systemd.daemon.notify("STATUS=First run sleep")
					# we only sleep a random amount the first time
					time.sleep(self.random_sleep_seed)
					
				current_sleep_counter+=1
				
				if current_sleep_counter >= sleep_counter or self.new_tag_signal:
						
					self.new_tag_signal=False
					current_sleep_counter=0
					
					try:
						systemd.daemon.notify("STATUS=Checking remote file")
						self.remote_actions=self.get_actions_file()
						if self.remote_actions!=None:
							if self.last_update!=self.remote_actions["last_update"]:
								self.pprint("Updating phase...")
								self.pprint("")
								self.last_update=self.remote_actions["last_update"]
								self.apt_cache=apt.Cache()
								self.pprint("\tUpdating cache...")
								try:
									self.apt_cache.update()
									# needs to be reopened after being updated
									self.apt_cache.open()
								except Exception as update_exc:
									if LliurexAutoUpgrade.IGNORE_UPDATE_ERROR:
										pass
									else:
										raise update_exc
										
								# this should not be necessary
								#self.pprint("\tValidating %h certificate..."%self.hostname)
								#self.check_certificate(self.hostname,self.org_id)
								self.pprint("\tGathering actions from server...")
								self.my_actions=self.gather_actions()
								self.print_my_actions()
								self.mark_update()
								self.mark_enforce()
								self.pprint("\tInhibiting shutdown...")
								fd_shutdown = manager.Inhibit("shutdown","lliurex-auto-upgrade","Updating system","block")
								real_fd=fd_shutdown.take()
								try:
									self.execute()
								finally:
									self.pprint("\tReleasing shutdown inhibition...")
									os.close(real_fd)
								self.pprint("Done")
								self.pprint("")
							else:
								self.pprint("Nothing to do")
								self.pprint("")
								systemd.daemon.notify("STATUS=Nothing to do. Waiting for new remote file or tag")
						
						if self.remote_actions != None:
							first_round_success=True
							
					except Exception as e:
						self.pprint("Exception: %s"%str(e))
							
					
					if first_round_success:
						self.pprint("Sleeping...")
						#time.sleep(LliurexAutoUpgrade.SLEEP_TIME)
						sleep_counter=LliurexAutoUpgrade.SLEEP_TIME
					else:
						error_count+=1
						if error_count == LliurexAutoUpgrade.MAX_RETRIES_FIRST_UPDATE:
							# next loop will wake in LliurexAutoUpgrade.SLEEP_TIME hour
							first_round_success=True
						else:
							# we have to reset last_update value to force new try after sleeping
							self.last_update=None
						self.pprint("Sleeping a reduced time since we failed to complete first run on try %s/%s ..."%(error_count,LliurexAutoUpgrade.MAX_RETRIES_FIRST_UPDATE))
						sleep_counter=LliurexAutoUpgrade.ALTERNATE_SLEEP_TIME
						#time.sleep(LliurexAutoUpgrade.ALTERNATE_SLEEP_TIME)
				else:
					pass
					#self.pprint("Sleeping... %s/%s"%(current_sleep_counter,sleep_counter))
					
				time.sleep(1)
				
		else:
			self.pprint("'%s' exists, service is disabled. Exiting..."%self.disable_file)
			
		
	#def __init__
	
	def pprint(self,data):
		
		if LliurexAutoUpgrade.DEBUG:
			print("[LAU] %s"%str(data))
			
		if LliurexAutoUpgrade.SYSLOG:
			syslog.syslog("[LAU] %s"%str(data).replace("\t","    "))
		
	#def pprint
	
	def write_pid(self):
		
		if os.path.exists(self.pid_file):
			f=open(self.pid_file)
			self.pid=int(f.read())
			f.close()
		
			if psutil.pid_exists(self.pid):
				self.pprint("Another lliurex-auto-upgrade process (%s) seems to be running. Exiting..."%self.pid)
				sys.exit(0)

		f=open(self.pid_file,"w")
		f.write(str(os.getpid()))
		f.close()
		
	#def write_pid	

	def start_inotify(self):

		t=threading.Thread(target=self.__inotify,name="lliurex-auto-upgrade.start_inotify thread")
		t.daemon=True
		t.start()

	#def start_inotify
	
	def __inotify(self):
		
		
		wm=WatchManager()
		mask=pyinotify.IN_CLOSE_WRITE
			
		class Process_handler(ProcessEvent):
				
			def __init__(self,main):
				
				self.main=main
				
			def process_IN_CLOSE_WRITE(self,event):

				self.main.pprint(event.pathname)
				self.main.pprint(event.name)
				systemd.daemon.notify("STATUS=New tag %s detected. Forcing new loop"%event.name)
				self.main.tags=self.main.get_tags()
				self.main.print_system_info()
				self.main.new_tag_signal=True
				self.main.last_update=None
	
		notifier=Notifier(wm,Process_handler(self))
		wdd=wm.add_watch(self.tags_dir,mask,rec=True)
			
		while True:
			try:
					
				notifier.process_events()
				if notifier.check_events():
					notifier.read_events()
				
			except Exception as e:
				self.pprint(e)
				notifier.stop()
					
		return False
	
	#def _inotify	
	
	def is_auto_update_configured(self):
		
		if os.path.exists(self.disable_file):
			return False
		
		return True
		
	#def is_auto_update_configured
	
	def is_package_from_lliurex_net(self,package):
		
		if not LliurexAutoUpgrade.ENFORCE_LLIUREX_NET:
			# if we dont enforce lliurex.net this check always returns true
			return True
		
		if package in self.apt_cache:
			if self.apt_cache[package].candidate.uri.startswith("http://lliurex.net/"):
				return True
				
		return False
		
	#def is_package_from_lliurexnet
	
	def is_package_installed(self,package):
		
		if package in self.apt_cache:
			return self.apt_cache[package].is_installed
			
		return False
		
	#def is_package_installed
	
	def is_package_upgradable(self,package):
		
		if package in self.apt_cache:
			if self.is_package_from_lliurex_net(package):
				return self.apt_cache[package].is_upgradable
			
		return False
		
	#def is_package_upgradable
	
	def check_certificate(self,hostname,org_id):
		
		cert=None
		verified=False
		context=ssl.create_default_context()
		try:
			with context.wrap_socket(socket.socket(), server_hostname=hostname) as s:
				s.connect((hostname,443))
				cert = s.getpeercert()
				
			if not cert:
				self.pprint("Failed to get certificate")
				
			if "subject" not in cert:
				self.pprint("Invalid certificate data")
			for item in cert["subject"]:
				key,value = item[0]
				if key=="organizationIdentifier":
					verified = value==org_id
			
		except Exception as e:
			self.pprint("Failed to verify certificate.")
			
		if not verfied:
			raise Exception("Failed to verify certificate.")
		
		return verified
		
	#def check_certificate
	
	def get_actions_file(self,url=None):
		
		data=None
		if url==None:
			url=self.actions_url
		
		if not os.path.exists("lliurex_actions.json"):
			try:
				response = requests.get(url)
				data = response.json()
			except Exception as e:
				self.pprint("Failed to download remote file.")
				data=None
		else:
			f=open("lliurex_actions.json")
			data=json.load(f)
			f.close()

		return data
		
	#def get_actions_file
	
	
	def get_lliurex_flavor(self):
		
		return subprocess.check_output("lliurex-version -f",shell=True).decode("utf-8").strip("\n")
		
	#def get_lliurex_flavor
	
	def get_tags(self):
		
		tags=[]
		if os.path.exists(self.tags_dir):
			dir_list=os.listdir(self.tags_dir)
			for item in dir_list:
				if os.path.isfile(self.tags_dir+item):
					tags.append(item)
		
		return tags
		
	#def get_tags
	
	def gather_actions(self):
		
		actions={}
		actions["update"]=[]
		actions["enforce"]=[]
		flavors=["common"]
		
		if self.flavor!=None:
			flavors.append(self.flavor)
		
		for flavor in flavors:
			
			if flavor in self.remote_actions["flavors"]:
				for action in self.remote_actions["flavors"][flavor]["update"]:
					if action not in actions["update"]:
						actions["update"].append(action)

				for action in self.remote_actions["flavors"][flavor]["enforce"]:
					if action not in actions["enforce"]:
						actions["enforce"].append(action)
					
		for tag in self.tags:
			
			if tag in self.remote_actions["tags"]:
				for action in self.remote_actions["tags"][tag]["update"]:
					if action not in actions["update"]:
						actions["update"].append(action)
			
				for action in self.remote_actions["tags"][tag]["enforce"]:
					if action not in actions["enforce"]:
						actions["enforce"].append(action)
		
		filtered_update=[]
		for update in actions["update"]:
			if self.is_package_installed(update):
				filtered_update.append(update)

		actions["update"]=filtered_update
		return actions
		
	#def gather_actions
	
	def mark_update(self):
		
		self.packages_to_update=False
		
		for package in self.my_actions["update"]:
			if self.is_package_upgradable(package):
				self.pprint("Marking %s update..."%package)
				self.apt_cache[package].mark_upgrade()
				self.packages_to_update=True
				
	#def mark_update
	
	def mark_enforce(self):
		
		self.packages_to_enforce=False
		
		for package in self.my_actions["enforce"]:
			if package in self.apt_cache and not self.is_package_installed(package) and self.is_package_from_lliurex_net(package):
				self.pprint("Marking %s enforce..."%package)
				self.packages_to_enforce=True
				self.apt_cache[package].mark_install()
			else:
				if self.is_package_upgradable(package):
					self.pprint("Marking %s enforce..."%package)
					self.packages_to_enforce=True
					self.apt_cache[package].mark_upgrade()
					
	#def mark_enforce
	
	def fixes_before_execution(self):
		
		if self.apt_cache.dpkg_journal_dirty:
			self.pprint("\t\tExecuting dpkg --configure -a ...")
			os.system("dpkg --configure -a")
		self.pprint("\t\tExecuting apt install -f...")
		os.system("apt install -f")
		# this call is caousing marked packages not to update. Trying to call apt install -f manually instead
		# self.apt_cache.fix_broken()
		
	#def fixes_before_execution
	
	def execute(self):
		
		if self.packages_to_update or self.packages_to_enforce:
			systemd.daemon.notify("STATUS=Checking apt/dpkg status before installing packages")
			self.pprint("\tUpdating system...")
			self.fixes_before_execution()
			systemd.daemon.notify("STATUS=Installing packages")
			self.pprint("\t\tInstalling updates...")
			self.apt_cache.commit()
		else:
			systemd.daemon.notify("STATUS=Nothing to execute, everything is up to date")
			self.pprint("")
			self.pprint("\tNothing to execute. Everything is up to date")
			self.pprint("")
		
	#def execute
	
	def print_my_actions(self):
		
		self.pprint("\tUpdate:")
		self.pprint("\t\t%s"%self.my_actions["update"])
		self.pprint("\tEnforce:")
		self.pprint("\t\t%s"%self.my_actions["enforce"])
		
	#def print_my_actions
	
	def print_system_info(self):
		
		self.pprint("")
		self.pprint("System info:")
		self.pprint("\tFlavor: %s"%str(self.flavor))
		self.pprint("\tTags: %s"%str(self.tags))
		self.pprint("")
		
	#def print_system_info
	
	
#class LliurexAutoUpdater


if __name__=="__main__":
	
	lau=LliurexAutoUpgrade()
