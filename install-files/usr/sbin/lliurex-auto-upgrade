#!/usr/bin/env python3

import os
import json
import random
import requests
import apt
import time
import sys
import psutil
import subprocess
import syslog


class LliurexAutoUpgrade:
	
	DEBUG=True
	SYSLOG=True
	RANDOM_SLEEP_WINDOW=30
	SLEEP_TIME=60*60
	
	def __init__(self):
		
		self.actions_url="http://svnlliurexnet.gva.es/leia/public/lliurex_actions.json"
		self.tags_dir="/etc/lliurex-auto-upgrade/tags/"
		self.disable_file="/etc/lliurex-auto-upgrade/disabled"
		self.pid_file="/run/lliurex-auto-upgrade.pid"
		self.packages_to_update=False
		self.packages_to_enforce=False
		self.sleep_time=LliurexAutoUpgrade.SLEEP_TIME
		self.random_sleep_seed=int(random.random()*LliurexAutoUpgrade.RANDOM_SLEEP_WINDOW)
		self.last_update=None
		
		self.write_pid()
		
		if self.is_auto_update_configured():
		
			self.flavor=self.get_lliurex_flavor()
			self.tags=self.get_tags()
		
			self.pprint("Starting...")
			self.print_system_info()
			
			while True:
				
				if self.last_update==None:
					#we only sleep a random amount the first time
					time.sleep(self.random_sleep_seed)
				try:
					self.remote_actions=self.get_actions_file()
					if self.remote_actions!=None:
						if self.last_update!=self.remote_actions["last_update"]:
							self.pprint("Updating phase...")
							self.pprint("")
							self.last_update=self.remote_actions["last_update"]
							self.apt_cache=apt.Cache()
							self.pprint("\tUpdating cache...")
							self.apt_cache.update()
							self.pprint("\tGathering actions from server...")
							self.my_actions=self.gather_actions()
							self.print_my_actions()
							self.mark_update()
							self.mark_enforce()
							self.execute()
							self.pprint("Done")
							self.pprint("")
						else:
							self.pprint("Nothing to do")
				except Exception as e:
					self.pprint("Exception: %s"%str(e))
						
				self.pprint("Sleeping...")
				time.sleep(self.sleep_time)
				
		else:
			self.pprint("'%s' exists, service is disabled. Exiting..."%self.disable_file)
			
		
	#def __init__
	
	def pprint(self,data):
		
		if LliurexAutoUpgrade.DEBUG:
			print("[LAU] %s"%str(data))
			
		if LliurexAutoUpgrade.SYSLOG:
			syslog.syslog("[LAU] %s"%str(data).replace("\t","    "))
		
	#def pprint
	
	def write_pid(self):
		
		if os.path.exists(self.pid_file):
			f=open(self.pid_file)
			self.pid=int(f.read())
			f.close()
		
			if psutil.pid_exists(self.pid):
				self.pprint("Another lliurex-auto-upgrade process (%s) seems to be running. Exiting..."%pid)
				sys.exit(0)

		f=open(self.pid_file,"w")
		f.write(str(os.getpid()))
		f.close()
		
	#def write_pid	
	
	def is_auto_update_configured(self):
		
		if os.path.exists(self.disable_file):
			return False
		
		return True
		
	#def is_auto_update_configured
	
	def is_package_installed(self,package):
		
		if package in self.apt_cache:
			return self.apt_cache[package].is_installed
		return False
		
	#def is_package_installed
	
	def is_package_upgradable(self,package):
		
		if package in self.apt_cache:
			return self.apt_cache[package].is_upgradable
			
		return False
		
	#def is_package_upgradable
	
	def get_actions_file(self,url=None):
		
		data=None
		if url==None:
			url=self.actions_url
		
		if not os.path.exists("lliurex_actions.json_"):
			try:
				response = requests.get(url)
				data = response.json()
			except Exception as e:
				print(e)
				data=None
		else:
			f=open("lliurex_actions.json")
			data=json.load(f)
			f.close()

		return data
		
	#def get_actions_file
	
	
	def get_lliurex_flavor(self):
		
		return subprocess.check_output("lliurex-version -f",shell=True).decode("utf-8").strip("\n")
		
	#def get_lliurex_flavor
	
	def get_tags(self):
		
		tags=[]
		if os.path.exists(self.tags_dir):
			dir_list=os.listdir(self.tags_dir)
			for item in dir_list:
				if os.path.isfile(self.tags_dir+item):
					tags.append(item)
		
		return tags
		
	#def get_tags
	
	def gather_actions(self):
		
		actions={}
		actions["update"]=[]
		actions["enforce"]=[]
		flavors=["common"]
		
		if self.flavor!=None:
			flavors.append(self.flavor)
		
		for flavor in flavors:
			
			for action in self.remote_actions["flavors"][flavor]["update"]:
				if action not in actions["update"]:
					actions["update"].append(action)
						
			for action in self.remote_actions["flavors"][flavor]["enforce"]:
				if action not in actions["enforce"]:
					actions["enforce"].append(action)
					
		for tag in self.tags:
			
			if tag in self.remote_actions["tags"]:
				for action in self.remote_actions["tags"][tag]["update"]:
					if action not in actions["update"]:
						actions["update"].append(action)
			
				for action in self.remote_actions["tags"][tag]["enforce"]:
					if action not in actions["enforce"]:
						actions["enforce"].append(action)
		
		filtered_update=[]
		for update in actions["update"]:
			if self.is_package_installed(update):
				filtered_update.append(update)

		actions["update"]=filtered_update
		return actions
		
	#def
	
	def mark_update(self):
		
		self.packages_to_update=False
		
		for package in self.my_actions["update"]:
			if self.is_package_upgradable(package):
				self.pprint("Marking %s update..."%package)
				self.apt_cache[package].mark_upgrade()
				self.packages_to_update=True
				
	#def mark_update
	
	def mark_enforce(self):
		
		self.packages_to_enforce=False
		
		for package in self.my_actions["enforce"]:
			if package in self.apt_cache and not self.is_package_installed(package):
				self.pprint("Marking %s enforce..."%package)
				self.packages_to_enforce=True
				self.apt_cache[package].mark_install()
			else:
				if self.is_package_upgradable(package):
					self.pprint("Marking %s enforce..."%package)
					self.packages_to_enforce=True
					self.apt_cache[package].mark_upgrade()
					
	#def mark_enforce
	
	def fixes_before_execution(self):
		
		if self.apt_cache.dpkg_journal_dirty:
			self.pprint("\t\tExecuting dpkg --configure -a ...")
			os.system("dpkg --configure -a")
		self.pprint("\t\tExecuting apt install -f...")
		self.apt_cache.fix_broken()
		
	#def fixes_before_execution
	
	def execute(self):
		
		if self.packages_to_update or self.packages_to_enforce:
			self.pprint("\tUpdating system...")
			self.fixes_before_execution()
			self.pprint("\t\tInstalling updates...")
			self.apt_cache.commit()
		else:
			self.pprint("")
			self.pprint("\tNothing to execute. Everything is up to date")
			self.pprint("")
		
	#def execute
	
	def print_my_actions(self):
		
		self.pprint("\tUpdate:")
		self.pprint("\t\t%s"%self.my_actions["update"])
		self.pprint("\tEnforce:")
		self.pprint("\t\t%s"%self.my_actions["enforce"])
		
	#def print_my_actions
	
	def print_system_info(self):
		
		self.pprint("")
		self.pprint("System info:")
		self.pprint("\tFlavor: %s"%str(self.flavor))
		self.pprint("\tTags: %s"%str(self.tags))
		self.pprint("")
		
	#def print_system_info
	
	
#class LliurexAutoUpdater


if __name__=="__main__":
	
	lau=LliurexAutoUpgrade()
